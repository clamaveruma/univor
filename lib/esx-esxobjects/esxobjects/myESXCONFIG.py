#!/usr/bin/python3
"""This module provides an object to implement several operations on VMWare ESX virtual machines using the pyvmomi API. This file is part if the myESX library."""

# Initialize logger
import logging

mylogger = logging.getLogger()

from .myESXVM import myESXVM
from pyVmomi import vim

from typing import List, Tuple, Optional, Any
import re, os
from datetime import datetime

class myESXPath:
    def __init__(self, esxpath:str):
        self.ds, self.path = self.validate_path(esxpath)

    def validate_path(self, esxpath:str) ->Tuple[str,str]:
        """Validate that the path contains a datastore and is not empty."""
        pattern_esxpath = r'^ *\[([\w+\-\.]+)\] */*(([\w+\-\.]+/)*[\w+\-\.]+) *$'
        result = match_res = re.match(pattern_esxpath, esxpath)
        if not result:
            raise ValueError(f"Path {esxpath} must contain a datastore in the form '[datastore] path/to/dir'.")
        else:
            return result.group(1),result.group(2)

    def fullPath(self) -> str:
        """Return the original esx path"""
        return f"[{self.ds}] {self.path}"

    def datastore(self) -> str:
        """Return the datastore name"""
        return self.ds

    def pathname(self) -> str:
        """Return only the directory part of the esx path without datastore"""
        return self.path

    def dirname(self) -> str:
        """Return the esx path with the basename of the file path"""
        return f"[{self.ds}] {os.path.dirname(self.path)}"

    def basename(self) ->str:
        """Return the basename portion of the esx path."""
        return os.path.basename(self.path)


class myESXPattern(myESXPath):
    def __init__(self, esxpath:str):
        """This class is used to validate a pattern for a path.
        The pattern is used to find files in a directory."""
        super().__init__(esxpath)

    def validate_path(self, esxpath:str) ->Tuple[str,str]:
        """Validate that the path contains a datastore and is not empty."""
        pattern_esxpath = r'^ *\[([\w+\-\.]+)\] */*(([\w+\-\.]+/)*[\w*+\-\.]+)? *$'
        result = match_res = re.match(pattern_esxpath, esxpath)
        if not result:
            raise ValueError(f"Path {esxpath} must contain a datastore in the form '[datastore] path/to/dir'.")
        else:
            if result.group(2):
                return result.group(1),result.group(2)
            else:
                return result.group(1),'*'

    def basename(self) -> str:
        if super().basename() == '':
            return '*'
        else:
            return super().basename()

class myESXNIC:
    """This object wraps a VirtualEthernetCard object. """

    device:vim.vm.device.VirtualEthernetCard

    def __init__(self, vdev:Optional[vim.vm.device.VirtualEthernetCard] = None):
        #No file operation is neeeded for a network card
        #devSpec.fileOperation = vim.vm.device.VirtualDeviceSpec.FileOperation.create
        if vdev:
            self.device = vdev

        else:
            self.device = vim.vm.device.VirtualE1000()
            self.device.key = -1
            self.device.BusSlotInfo
            self.device.addressType = vim.vm.device.VirtualEthernetCardOption.MacTypes.generated
            #self.device.macAddress = 'Generated'
            self.device.connectable = vim.vm.device.VirtualEthernetCard.ConnectInfo()
            self.device.connectable.startConnected = True
            self.device.connectable.allowGuestControl = True


    def getDev(self) -> vim.vm.device.VirtualEthernetCard:
        return self.device

    def setNetwork(self, network:vim.Network):
        """Set the network to which this card is connected.
        
        :param network_name: A vim.Network objetc.
        """
        self.device.backing = vim.vm.device.VirtualEthernetCard.NetworkBackingInfo()
        self.device.backing.useAutoDetect = True
        self.device.backing.deviceName = network.name
        self.device.backing.network = network

    def setMAC(self, mactype:str, macaddr:str = ''):
        """Set the mac for the interface.
        
        :param mactype: 'auto' sets the MAC type to be autogenerated by the ESX server. 'manual' requires
        providing the mac addres.
        :param macaddr: The mac address to set if mactype is manual."""
        match mactype:
            case 'auto' | 'automatic' | 'generated':
                self.device.addressType = vim.vm.device.VirtualEthernetCardOption.MacTypes.generated
                if macaddr:
                    mylogger.warning('MAC address parameter is not empty and address type is ''auto''.')
                else:
                    self.device.macAddress = None
            case 'manual':
                self.device.addressType = vim.vm.device.VirtualEthernetCardOption.MacTypes.manual
                if not macaddr:
                    mylogger.error('MAC address parameter is empty and address type is ''manual''.')
                else:
                    self.device.macAddress = macaddr

class myESXVDISK:
    """This object wraps a VirtualDisk object. """
    device:vim.vm.device.VirtualDisk

    def __init__(self, vdev:Optional[vim.vm.device.VirtualDisk] = None):
        #No file operation is neeeded for a network card
        #devSpec.fileOperation = vim.vm.device.VirtualDeviceSpec.FileOperation.create
        if vdev:
            self.device = vdev
        else:
            self.device = vim.vm.device.VirtualDisk()
            self.device.backing = vim.vm.device.VirtualDisk.SeSparseBackingInfo()
            self.device.backing.diskMode = 'undoable'
            self.device.backing.writeThrough = False

    def getDev(self) -> vim.vm.device.VirtualDisk:
        return self.device

    def setPath(self, vmPath:str):
        """Set the network to which this card is connected.
        
        :param network_name: A vim.Network objetc.
        """
        backing:Optional[vim.vm.device.VirtualDisk.SeSparseBackingInfo] = self.device.backing # type: ignore
        if backing:
            current:str = backing.fileName
            base = os.path.basename(current)
            backing.fileName = f'{vmPath}/{base}'


class myESXCONFIG:
    """This object manages an object to hold the configuration of a VM"""

    def __init__(self, vm:Optional[myESXVM] = None):
        """
        If a vm is provided, the object is initialized with its configuration.
        If not, an empty configuration is generated.
        """
        if vm and vm.vm:
            self.specs = self._getConfigSpec(vm)
        else:
            self.specs = vim.vm.ConfigSpec()

    def getConfigSpec(self) -> vim.vm.ConfigSpec:
        """Obtain the internal VIM object containing the configuration.
        
        :return: A ConfigSpec object containing a configuration.
        """
        return self.specs

    def setName(self, name:str):
        """Set the name of the VM in the specifications."""
        self.specs.name = name

    def setDir(self, vmPath:str):
        """Set the path of the VM directory in the specifications.
        
        It sets also the default directory for snapshots, suspend and logs."""
        if not self.specs.files:
            self.specs.files = vim.vm.FileInfo()
        self.specs.files.vmPathName = vmPath
        self.specs.files.snapshotDirectory = vmPath
        self.specs.files.suspendDirectory = vmPath
        self.specs.files.logDirectory = vmPath

    def setCPU(self, numCPUs:int, numCoresPerSocket:int = 1):
        """SEts the configuration of the CPUs of the VM.
        Total number of Sockets is numCPU / numCoresPerSocket.

        :param numCPUs: Total number of Cores.
        :numCoresPerSocket: Numer of cores per socket."""
        self.specs.cpuFeatureMask = []
        self.specs.numCPUs = numCPUs
        self.specs.numCoresPerSocket = numCoresPerSocket

    def setMemory(self, memMB:int):
        """Sets the ammount of RAM memory of the VM.
        
        :param memMB: Ammount of RAM memory in MB."""
        self.specs.memoryMB = memMB # type: ignore

    def setNestedHV(self, state:Optional[bool]):
        """Sets the Nested Hardware Virtualization flag to the given value.
        The nestedHVEnabled flag controls if the CPU support hardware for virtualization is exposed
        inside the VM to allow it to act as an hypervisor using KVM or VMware.
        
        :param state: Desired state of the nestedHVEnabled flag."""
        self.specs.nestedHVEnabled = state

    def setHotplug(self, cpuadd:Optional[bool], cpuremove:Optional[bool], memory:Optional[bool]):
        """Sets the flags for resources that can be hotadded.
        The cpuHotAddEnabled flag controls if CPUs can be added while poweron.
        The cpuHotRemoveEnabled flag controls if CPUs can be removed while poweron.
        The memoryHotAddEnabled flag controls if CPUs can be added while poweron.
        
        :param state: Desired state of the nestedHVEnabled flag."""
        self.specs.cpuHotAddEnabled = cpuadd
        self.specs.cpuHotRemoveEnabled = cpuremove
        self.specs.memoryHotAddEnabled = memory

    def clearDevices(self):
        """Clear the list of devices of the ConfigSpec object."""
        self.specs.deviceChange = []

    def findNICdevSpec(self, network:Optional[vim.Network] = None, macaddress:str = '', mactype:Optional[vim.vm.device.VirtualEthernetCardOption.MacTypes] = None, nicNum:Optional[int] = None) -> List[vim.vm.device.VirtualDeviceSpec]:
        """Find any interface matching the parameters which have been defined.
        :param network: An object for one network group.
        :param macaddress: A string with the MAC address.
        :param mactype: A string describing the MAC type.
        :return: A list of device specifications."""
        devspecs = []
        for devSpec in self.specs.deviceChange:
            if isinstance(devSpec.device, vim.vm.device.VirtualEthernetCard):
                if (not nicNum or devSpec.device.key == (4000 + nicNum)) and (not mactype or devSpec.device.addressType == mactype) and (not macaddress or devSpec.device.macAddress == macaddress) and (not network or devSpec.device.backing.network == network): # type: ignore
                    devspecs.append(devSpec)
        return devspecs

    def findVDISK(self, label:Optional[str] = None) -> List[vim.vm.device.VirtualDeviceSpec]:
        """Find any interface matching the parameters which have been defined.
        :param network: An object for one network group.
        :param macaddress: A string with the MAC address.
        :param mactype: A string describing the MAC type.
        :return: A list of device specifications."""
        devspecs = []
        for devSpec in self.specs.deviceChange:
            if isinstance(devSpec.device, vim.vm.device.VirtualDisk):
                if (not label or devSpec.device.deviceInfo.label == label): # type: ignore
                    devspecs.append(devSpec)
        return devspecs

    def delSpec(self, dev:vim.vm.device.VirtualDeviceSpec):
        """Mark an existing device specification to be removed. The specification must be obtained with findNICdevSpec or other find functions.
        
        :param dev: A device specification to be removed."""
        dev.operation = vim.vm.device.VirtualDeviceSpec.Operation.remove
        return None
   
    def editdevSpec(self, dev:vim.vm.device.VirtualDeviceSpec):
        """Mark an existing device specification to be changed. The specification must be obtained with findNICdevSpec or other find functions.
        The device properties included in this device specification should have been edited.
        
        :param dev: A device specification to be edited."""
        dev.operation = vim.vm.device.VirtualDeviceSpec.Operation.edit
        return None
    
    def addNIC(self, vnic:myESXNIC):
        """Create a new device specification based on the definition of the NIC passed as argument.
        
        :param vnic: The description of this Network Card"""
        # Request to add this operation to the new VM
        devSpec = vim.vm.device.VirtualDeviceSpec()
        devSpec.operation = vim.vm.device.VirtualDeviceSpec.Operation.add
        #No file operation is neeeded for a network card
        #devSpec.fileOperation = vim.vm.device.VirtualDeviceSpec.FileOperation.create
        #
        devSpec.device = vnic.getDev()
        self.specs.deviceChange.append(devSpec)
    
    def addVDISK(self, vdisk:myESXVDISK):
        """Create a new device specification based on the definition of the NIC passed as argument.
        
        :param vnic: The description of this Network Card"""
        # Request to add this operation to the new VM
        devSpec = vim.vm.device.VirtualDeviceSpec()
        devSpec.operation = vim.vm.device.VirtualDeviceSpec.Operation.add
        # File operation is neeeded for a new disk
        devSpec.fileOperation = vim.vm.device.VirtualDeviceSpec.FileOperation.create
        #
        devSpec.device = vdisk.getDev()
        self.specs.deviceChange.append(devSpec)
    
    def _getConfigSpec(self, esxvm:myESXVM) -> vim.vm.ConfigSpec:
        """Build a ConfigSpec object with the configuration of this virtual machine.
        The object is used to create virtual machines with the same hardware configuration of this
        virtual machine.
        Network interfaces contain the same MAC and MAC type as the original. The confgiurations
        should be updated to change those values with new MACs in case of creating a cloned VM.
        Virtual Disks contain the same file references as the original. The configuration can not
        be used without editing the disk devices to replace the file references.
        The same applies for the name and the directory of the virtual machine.

        :return: A ConfigSpec() object with a copy of the configuration and devices that can be used
        in datacenter.vmFolder.CreateVM_Task().
        """

        # This attributes have to be skipped because do not exist in destination or have to be treated specially
        skipAttributes = ['hardware','cpuFeatureMask','extraConfig','datastoreUrl','guestFullName','modified','template','initialOverhead']
        # This are attributes which have different names in both data structures
        crossAttributes = [('defaultPowerOps','powerOpInfo')]
        # This complex attributes should be copied directly
        complexAttributes = ['bootOptions','cpuAllocation','flags','scheduledHardwareUpgradeInfo','tools','files','vcpuConfig','npivNodeWorldWideName','npivPortWorldWideName','latencySensitivity','memoryAllocation']

        
        # This is the new configuration
        newHW = vim.vm.ConfigSpec()
        # This is the old configuration
        srcHW = esxvm.vm.config

        # Remove from config the items starting with '_' and Array from vm.config
        allItems = [(item,getattr(srcHW,item)) for item in dir(srcHW) if re.match(r'^(Array|dynamicProperty|_+.*)',item)== None]
        # Remove items with null values or empty Lists
        validItems = [(item,value) for item,value in allItems if value != None and value != []]

        # Copy attributes with same item names from VM to Spec
        for item,value in validItems:
            itemT=type(value)

            # Skip attributes to treat specifically or not applicable in new VM
            if item in skipAttributes:
                continue

            # Copy items with different names in VM and Spec
            map = [(srcItem,dstItem) for srcItem,dstItem in crossAttributes if srcItem == item]
            if map != []:
                # Assign destination item name
                [ setattr(newHW,dst,value) for src,dst in map]
                continue

            # Check for empty Lists (no need to copy)
            if value == []:
                #print(f"{item} === {value}")
                #setattr(hw,item,value)
                mylogger.debug(f'Attribute {item}=[] not copied to ConfigSpec()')
                continue

            # Copy attributes with simple data types or known complex attributes and same name
            if itemT==int or itemT==float or itemT==bool or itemT==str or itemT==datetime or item in complexAttributes:
                if hasattr(newHW, item):
                    # Assign destination item name
                    setattr(newHW,item,value)
                else:
                    # Attribute does not exist in destination
                    mylogger.warning(f'Attribute {item}={value} does not exist in ConfigSpec()')
                continue

            # Check for complex vmomi types
            if re.match(r'.*(vim|pyVmomi).*',str(itemT)) != None:
                mylogger.warning(f"Attribute {item}:{str(itemT)} ={value} not copied to ConfigSpec()")
                continue
                if hasattr(newHW,item):
                    try:
                        setattr(newHW, item, value)
                    except Exception:
                        print(f"FIELDS don't have the same type: {item}")
                else:
                    print(f"SKIP:NOT IN SPEC: {item} = {itemT}")
            # Extranger types
            mylogger.warning(f"Unkown field {item}:{str(itemT)} in ConfigSpec()")     
            

        ################################################
        # Check for special items complex to process

        # item: cpuFeatureMask
        # This function 
        def _getMask(m):
            cpuid = vim.vm.ConfigSpec.CpuIdInfoSpec()
            cpuid.info=m
            cpuid.operation = vim.option.ArrayUpdateSpec.Operation.add
            return cpuid
        if srcHW.cpuFeatureMask: # type: ignore
            newHW.cpuFeatureMask = [_getMask(m) for m in srcHW.cpuFeatureMask] # type: ignore

        # item: hardware
        if srcHW: # This if is to calm type checking
            newHW.numCPUs = srcHW.hardware.numCPU
            newHW.numCoresPerSocket = srcHW.hardware.numCoresPerSocket
            newHW.memoryMB = srcHW.hardware.memoryMB # type: ignore
            newHW.virtualICH7MPresent = srcHW.hardware.virtualICH7MPresent
            newHW.virtualSMCPresent = srcHW.hardware.virtualSMCPresent

        # List of VM devices
        newHW.deviceChange = []
        return newHW

    def _copyNetworkDevices(self, esxvm:myESXVM):
        """Copy network devices to the list of new devices.
        The object is used to create virtual machines with the same hardware configuration of this
        virtual machine.
        Network interfaces contain the same MAC and MAC type as the original. The confgiurations
        should be updated to change those values with new MACs in case of creating a cloned VM.
        Virtual Disks contain the same file references as the original. The configuration can not
        be used without editing the disk devices to replace the file references.
        The same applies for the name and the directory of the virtual machine.

        :return: A ConfigSpec() object with a copy of the configuration and devices that can be used
        in datacenter.vmFolder.CreateVM_Task().
        """
        for srcDev in esxvm.vm.config.hardware.device: # type: ignore
            # NETWORK CARDS
            if isinstance(srcDev, vim.vm.device.VirtualEthernetCard):
                # Request to add this operation to the new VM
                devSpec = vim.vm.device.VirtualDeviceSpec()
                devSpec.operation = vim.vm.device.VirtualDeviceSpec.Operation.add
                #No file operation is neeeded for a network card
                #devSpec.fileOperation = vim.vm.device.VirtualDeviceSpec.FileOperation.create
                #
                #devSpec.device = vdev
                devSpec.device = vim.vm.device.VirtualE1000()
                devSpec.device.key = -1
                devSpec.device.unitNumber = srcDev.unitNumber
                devSpec.device.wakeOnLanEnabled = srcDev.wakeOnLanEnabled
                devSpec.device.addressType = srcDev.addressType
                devSpec.device.macAddress = srcDev.macAddress
                
                if srcDev.deviceInfo:
                    devSpec.device.deviceInfo = vim.Description()
                    devSpec.device.deviceInfo.label = srcDev.deviceInfo.label
                    devSpec.device.deviceInfo.summary = srcDev.deviceInfo.summary
                if srcDev.backing:
                    devSpec.device.backing = vim.vm.device.VirtualEthernetCard.NetworkBackingInfo()
                    devSpec.device.backing.deviceName = srcDev.backing.deviceName
                    devSpec.device.backing.network = srcDev.backing.network
                    devSpec.device.backing.useAutoDetect = srcDev.backing.useAutoDetect
                if srcDev.connectable:
                    devSpec.device.connectable = vim.vm.device.VirtualDevice.ConnectInfo()
                    devSpec.device.connectable.startConnected = srcDev.connectable.startConnected
                    devSpec.device.connectable.allowGuestControl = srcDev.connectable.allowGuestControl
                self.specs.deviceChange.append(devSpec)

    def _copyDiskDevices(self, esxvm:myESXVM, dstPath:str):
        """Copy disk devices to the list of new devices.
        The object is used to create virtual machines with the same hardware configuration of this
        virtual machine.
        Network interfaces contain the same MAC and MAC type as the original. The confgiurations
        should be updated to change those values with new MACs in case of creating a cloned VM.
        Virtual Disks contain the same file references as the original. The configuration can not
        be used without editing the disk devices to replace the file references.
        The same applies for the name and the directory of the virtual machine.

        :param esxvm: An object of type myESXVM containing the source virtual machine.
        :param dstPath: The destination path where the disks will be created. The path should be in the form '[datastore] path/to/dir'. The path is used to set the fileName of the disk backing.
        :return: A ConfigSpec() object with a copy of the configuration and devices that can be used
        in datacenter.vmFolder.CreateVM_Task().
        """
        for srcDev in esxvm.vm.config.hardware.device: # type: ignore
            # VIRTUAL CONTROLLER
            if isinstance(srcDev, vim.vm.device.VirtualSCSIController):
                # Request to add this operation to the new VM
                devSpec = vim.vm.device.VirtualDeviceSpec()
                devSpec.operation = vim.vm.device.VirtualDeviceSpec.Operation.add

                #devSpec.device = srcDev
                devSpec.device = type(srcDev)()
                devSpec.device.key = srcDev.key
                devSpec.device.sharedBus = vim.vm.device.VirtualSCSIController.Sharing.noSharing
                self.controllerKey = srcDev.key
                self.specs.deviceChange.append(devSpec)


        for srcDev in esxvm.vm.config.hardware.device: # type: ignore
            # VIRTUAL DISKS
            if isinstance(srcDev, vim.vm.device.VirtualDisk):
                # Request to add this operation to the new VM
                devSpec = vim.vm.device.VirtualDeviceSpec()
                devSpec.operation = vim.vm.device.VirtualDeviceSpec.Operation.add
                #No file operation is neeeded for a network card
                devSpec.fileOperation = vim.vm.device.VirtualDeviceSpec.FileOperation.create
                #
                #devSpec.device = srcDev
                devSpec.device = vim.vm.device.VirtualDisk()
                devSpec.device.key = -1
                devSpec.device.controllerKey = srcDev.controllerKey
                devSpec.device.unitNumber = srcDev.unitNumber
                #
                devSpec.device.capacityInKB = srcDev.capacityInKB
                devSpec.device.capacityInBytes = srcDev.capacityInBytes

                #devSpec.device.key = -1
                #devSpec.device.BusSlotInfo
                #devSpec.device.backing = vdev.backing
                if srcDev.deviceInfo:
                    devSpec.device.deviceInfo = vim.Description()
                    devSpec.device.deviceInfo.label = srcDev.deviceInfo.label
                    devSpec.device.deviceInfo.summary = srcDev.deviceInfo.summary
                if srcDev.backing:
                    devSpec.device.backing = vim.vm.device.VirtualDisk.FlatVer2BackingInfo()
                    devSpec.device.backing.diskMode = "persistent"
                    devSpec.device.backing.fileName = f'{dstPath}/{myESXPath(srcDev.backing.fileName).basename()}'
                    devSpec.device.backing.parent = srcDev.backing
                    #devSpec.device.backing.writeThrough = False
                    #devSpec.device.backing.sharing = srcDev.backing.sharing
                    #devSpec.device.backing.thinProvisioned = srcDev.backing.thinProvisioned
                    devSpec.device.backing.thinProvisioned = True
                    #devSpec.device.backing.split = False
                    #devSpec.device.backing.digestEnabled = False

                self.specs.deviceChange.append(devSpec)

    def _copyCDROMDevices(self, esxvm:myESXVM):
        """Copy network devices to the list of new devices.
        The object is used to create virtual machines with the same hardware configuration of this
        virtual machine.
        Network interfaces contain the same MAC and MAC type as the original. The confgiurations
        should be updated to change those values with new MACs in case of creating a cloned VM.
        Virtual Disks contain the same file references as the original. The configuration can not
        be used without editing the disk devices to replace the file references.
        The same applies for the name and the directory of the virtual machine.

        :return: A ConfigSpec() object with a copy of the configuration and devices that can be used
        in datacenter.vmFolder.CreateVM_Task().
        """
        for vdev in esxvm.vm.config.hardware.device: # type: ignore
            # VIRTUAL CDROMs
            if isinstance(vdev, vim.vm.device.VirtualCdrom):
                # Request to add this operation to the new VM
                devSpec = vim.vm.device.VirtualDeviceSpec()
                devSpec.operation = vim.vm.device.VirtualDeviceSpec.Operation.add
                #No file operation is neeeded for a network card
                #devSpec.fileOperation = vim.vm.device.VirtualDeviceSpec.FileOperation.create
                #
                devSpec.device = vdev
                #
                #devSpec.device.key = -1
                #devSpec.device.BusSlotInfo
                #devSpec.device.backing = vdev.backing
                
                #devSpec.device.backing.useAutoDetect = True
                #devSpec.device.backing.network = None
                self.specs.deviceChange.append(devSpec)
